exploration stages;

1. intro, learn its a second layer to the internet
basic node collection.
see some creatures, but dont know they are creatures yet.

2. learn how to "unlock" locations. encouter cats location, but cant read it (first unreadable stuff). Cat1 requires fish to open. Links too Cat2 that requires many types of fish.

3. Go to first remote location. Learn about languages. Gain first ability (decode language1)
(more creatures here, a different sort)

4. Using new nodes gained, can unlock profs research node.
Mentions creatures for the first time. Speculates they might react
to data.


- learn creatures eat data, use it up
- learn creatures adapt and each population will only be vulnerable to each type of data once
- learn computers arnt locked, they are corrupted. Prof didnt lock his machine


- Concept gun (can be equiped with different objects that determain beams propertys)
  * objects get used up slower then directly giving them (due to guns rating ratio)
	
	concepts to load into gun (should have visual effects)
	 color = effects color, naturally
	 big/small = beams width
	 
	 posion = damage over time effect
	 fire = damage over time effect
	 freeze = stops movement, puts out fire
	 chain = leaps from one to another
	 wind = spreads them out 
	 
	 in addition to these effects the concept can apply its own unique property (ie, milk would effect lactor intolrent nodes)
	 
	 
	 Gun level determains concept complexity (ie, how many classes it can have)
	 
	 
	 
	 
	 Location tools;
	 (these are seperate single use locations. They are locked like others, but the metaphor for unlocking is "needing research data"
	 to complete something)
	 
	 - Concept anylser - displays details of concept
	 - Creature anayliser (How to detect what creature to anylise?)
	 
 
  

- gain mutator device? (but only after dealing with a few populations in other ways)




Creature types;

* Vulnerable just to clicks
* Vulnerable to milk,cheese,yogaurt,etc 
* Vulnerable to fruit

Population types;

* light investation (surrounds location, but doesnt interfere)
  - gives drops

* heavy. (blocks locations use by swaming over it/greying it out. ALL have to be removed
to open location)

Characters;

ProP - studys and explorers the locations. uses outdated lingo.
Bob - shared client with you. irrasponsible
Alice - exodecypter. likes icecream. low attention span.
Cat - a cat? speaks Moew.

Darkflame - first remote terminal...exadurated me

Unused;

Gondalwind - 

Lock/puzzle ideas;
-----------------

Name 6 doctors (doctor who actors count, as does any fictional doctor)

Opersite lock - each clue has something you need to give the opersite off (many locks)

Language lock - "Hello?Hello?Hello?" (reply with Hellos in any 3 languages)

Property - "Melting point over 300+solid" (materials like tungstan)
         - Alive, non Vertebrate
         
Large quanitys - 10 lifeforms or 10 round things

Maths Puzzle - basic sum/answer

Quiz - name the 5 Marx brothers
	 - a marvel/dc superhero 
	 - acted in films X and Y



Complete - complete a sentance? 
		 - Complete a set (some already filled in?)
		 





Letters

Darkflame


This is cool. Its like some sort of semantic based network. Each domain adds its knowledge
to the network.
Semantics are really cool. Awesome in fact. Transitional inherirance of knowledge alone plus
crossreferancing equals massive deductive power.
Everyone should love semantic systems.Knowledge linked together in a structure, like a mesh of propertys and subpropertys,
allowing different concepts to be related, allowing reality to be interpreted by humans and machines alike. Semantics in many ways is knowledge
Subject Object Verb. Subject Predicate Value.  Semantics! Semantics!
Semantics!
--
AR is cool too. Augmented Reality. One day we will live in a half virtual world. I am sure of it.
Anyone seen Dennou Coil? You should!
--
I know Semantic AR!! No...wait...that makes no sense. Also Why do I keep emailing myself. ? 
--
oh, I also spotted some weird...things...around some locations.  Anyone else spotted them? I thought they were just random data 
at first, but they seem to respond to interaction. 


How to handle creature movements?

- Movement is defined by basic actions nodes
- [Turn X left],[Turn X right],[Turn Towards <Point>],[Move Forward X],[Move Back X]

- Node file can determain a set of sub-actions to proform under an action
"[Run From <Point>]" contains "[Turn Towards <Point>],[Turn 180 right],[Move Forward X]"

- Node file can determain action to do under conditions


- Creatures have a updatePosition() function which calls getPosition(delta) from their animationController

- getPosition(delta) in animation controller returns the position based on the current action. If it reachs the end 
of the current action, it skips to the next action in its current list and returns the position in that





Widgets to make

1. Mock GWT label - scalable in 3d using distance map fonts (or whatever its calleD). Has all the basic propertys of a label.

2. Vertical/Horizontal panel - can accept the above label for now, but support it via a GWTish widget interface





/////-----------------------------------
/////-----------------------------------

//Work in progress lazerbeam

precision highp float;
uniform float time;
uniform vec2 resolution;
varying vec3 fPosition;
varying vec3 fNormal;

void main()
{
  
  float x = fPosition.x;
  float y = fPosition.y;
  
  vec4 col = vec4(0,0,0,0);  
  
  if (y<0.04 && y>-0.04) 
  {
        
        //red bit
        
    float intensity = (0.04-abs(y))*(1.0/0.04); //should result in 0-1 range
    
    float r = 1.0*intensity;
    float g = 0.0*intensity;
    float b = 0.0*intensity;
    float a = 1.0*intensity;
    
    col = vec4(r,g,b,a);  
    
    //white core
    
     intensity  = (0.04-abs(y*5.0))*(1.0/0.04);
     
     if (intensity<0.0){
       intensity = 0.0;
     }
     
    float r2 = 1.0*intensity;
    float g2 = 1.0*intensity;
    float b2 = 1.0*intensity;
    float a2 = 1.0*intensity;
    vec4 col2 = vec4(r2,g2,b2,a2);
    
     col = col+col2;
    
    
    //col = vec4(r+r2,g+g2,b+b2,a);  
    
    
  }
  
  
  gl_FragColor = col;
  
}

//with pulse

precision highp float;
uniform float time;
uniform vec2 resolution;
varying vec3 fPosition;
varying vec3 fNormal;

void main()
{
  
  float x = fPosition.x;
  float y = fPosition.y;
  
  vec4 col = vec4(0,0,0,0);  
  
  if (y<0.04 && y>-0.04) 
  {
        
        //red bit
        
    float intensity = (0.04-abs(y))*(1.0/0.04); //should result in 0-1 range
    
    float r = 1.0*intensity;
    float g = 0.0*intensity;
    float b = 0.0*intensity;
    float a = 1.0*intensity;
    
    col = vec4(r,g,b,a);  
    
    //white core
    float tsin = abs(sin((50.0*time)-x));
    float corethick = 10.0-(8.0*(tsin));
    
     intensity  = (0.04-abs(y*corethick))*(1.0/0.04);
     
     if (intensity<0.0){
       intensity = 0.0;
     }
     
    float r2 = 1.0*intensity;
    float g2 = 1.0*intensity;
    float b2 = 1.0*intensity;
    float a2 = 1.0*intensity;
    vec4 col2 = vec4(r2,g2,b2,a2);
    
    
    vec4 col3 = vec4(0,0,0,0);
    
     col = col+col2;
    
    
    //col = vec4(r+r2,g+g2,b+b2,a);  
    
    
  }
  
  //end bit
  //float xgrad = sin((x-0.1)*9.0)*1.0;
  
  float abx=1.2-abs(x-0.9); //0 to 1 based on distance from center
  float eppx=pow(abx,5.0);//
  float xgrad =(eppx);
  if (xgrad<0.0){
    xgrad=0.0;
  }
  
  float aby=1.0-abs(y); //0 to 1 based on distance from center
  float epp=pow(aby,9.0);//
  float ygrad =(epp);
  if (ygrad<0.0){
    ygrad=0.0;
  }
  vec4 col3 = vec4(xgrad*ygrad,xgrad*ygrad,xgrad*ygrad,xgrad*ygrad);
    
   col = col+col3;
  
  
  gl_FragColor = col;
  
}

//Lazer  + pulse + Animated impact

precision highp float;
uniform float time;
uniform vec2 resolution;
varying vec3 fPosition;
varying vec3 fNormal;

void main()
{
  
  float x = fPosition.x;
  float y = fPosition.y;
  
  vec4 col = vec4(0,0,0,0);  
   float tsin = abs(sin((50.0*time)-x));
  if (y<0.04 && y>-0.04) 
  {
        
        //red bit
        
    float intensity = (0.04-abs(y))*(1.0/0.04); //should result in 0-1 range
    
    float r = 1.0*intensity;
    float g = 0.0*intensity;
    float b = 0.0*intensity;
    float a = 1.0*intensity;
    
    col = vec4(r,g,b,a);  
    
    //white core
   
    float corethick = 10.0-(8.0*(tsin));
    
     intensity  = (0.04-abs(y*corethick))*(1.0/0.04);
     
     if (intensity<0.0){
       intensity = 0.0;
     }
     
    float r2 = 1.0*intensity;
    float g2 = 1.0*intensity;
    float b2 = 1.0*intensity;
    float a2 = 1.0*intensity;
    vec4 col2 = vec4(r2,g2,b2,a2);
    
    
    vec4 col3 = vec4(0,0,0,0);
    
     col = col+col2;
    
    
    //col = vec4(r+r2,g+g2,b+b2,a);  
    
    
  }
  
  //end bit
  //float xgrad = sin((x-0.1)*9.0)*1.0;
  
  float abx=1.1-abs(x-0.9); //0 to 1 based on distance from center
  if (abx<0.0){
    abx = 0.0;
  }
  float eppx=pow(abx,5.0);//
  float xgrad =(eppx)*tsin;
  if (xgrad<0.0){
    xgrad=0.0;
  }
  
  float aby=1.0-abs(y); //0 to 1 based on distance from center
  float epp=pow(aby,9.0);//
  float ygrad =(epp)*tsin;
  if (ygrad<0.0){
    ygrad=0.0;
  }
  
  vec4 col3 = vec4(xgrad*ygrad,xgrad*ygrad,xgrad*ygrad,xgrad*ygrad);
    
   col = col+(col3);
  
  
  gl_FragColor = col;
  
}
